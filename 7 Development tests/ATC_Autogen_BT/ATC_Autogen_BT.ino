/*
 * ArduinoTC Autogenerated Code for HC05/HC06 and HM10 modules.
 * Layout:
 * Date:
 */

#define BAUD_RATE 9600

// Special commands
#define CMD_SPECIAL '<'
#define CMD_ALIVE   '['

// Toggle buttons set-up
#define MAX_TBUTTON 6
const int TButton_Output[MAX_TBUTTON] = {13, 12, 11, 10, 9, 8};
const String TButton_ID[MAX_TBUTTON] = {"00", "01", "02", "03", "04", "05"};
const char TButton_CMD_ON[MAX_TBUTTON] = {'A', 'B', 'C', 'D', 'E', 'F'};
const char TButton_CMD_OFF[MAX_TBUTTON] = {'a', 'b', 'c', 'd', 'e', 'f'};

// Image Button Setup
#define MAX_IBUTTON 6
const int IButton_Output[MAX_IBUTTON] = {13, 12, 11, 10, 9, 8};
const char IButton_CMD_ON[MAX_IBUTTON] = {'A', 'B', 'C', 'D', 'E', 'F'};
const char IButton_CMD_OFF[MAX_IBUTTON] = {'a', 'b', 'c', 'd', 'e', 'f'};

// Text object setup
#define MAX_TEXT 6
const String TEXT_ID[MAX_TEXT] = {"00", "01", "02", "03", "04", "05"};

// Image object setup
#define MAX_IMG 6
const int IMG_Input[MAX_IMG] = {7, 6, 5, 4, 3, 2};
const String IMG_ID[MAX_IMG] = {"00", "01", "02", "03", "04", "05"};

// Touch pad setup
int TouchPadData[24][2]; // 24 max touch pad objects, each one has 2 axis (x and Y)

// Acceleration data setup
int Accel[3] = {0, 0, 0};

// Seek bar data setup
int SeekBarValue[8] = {0, 0, 0, 0, 0, 0, 0, 0};

// Voice commands setup
String SpeechRecorder = "";

void setup() {
  // initialize BT Serial port and greet app
  Serial.begin(BAUD_RATE);
  Serial.println("ATC Expert BT");
  Serial.println("<TtoS00: welcome to ATC expert");
  
  // Initialize touch pad data
  for(int i = 0; i < 24; i++){
    TouchPadData[i][0] = 0; //X
    TouchPadData[i][1] = 0; //Y
  }

  // Initialize Image Button output ports
  for (int i = 0; i < MAX_IBUTTON; i++) {
    pinMode(IButton_Output[i], OUTPUT);
  }

  // Initialize Toggle Button output ports
  for (int i = 0; i < MAX_TBUTTON; i++) {
    pinMode(TButton_Output[i], OUTPUT);
  }

  // Initialize digital input pins for image data
  for (int i = 0; i < MAX_IMG; i++) {
    pinMode(IMG_Input[i], INPUT_PULLUP);
  }  
}

void loop() {
  int appData;
  static int digitalPrescaler = 0;
  delay(1);

  // ===========================================================
  appData = Serial.read();   // Get a byte from app, if available
  switch (appData) {
    case CMD_SPECIAL:
      // Special command received
      DecodeSpecialCommand();

      // Example of how to use seek bar data to dim a LED connected in pin 13
      // analogWrite(13, SeekBarValue[5]);

      // Example of how to use speech recorder
      //Serial.println(SpeechRecorder); // display received voice command
      //if(SpeechRecorder.equals("turn off")){
      //}
      //if(SpeechRecorder.equals("turn on")){
      //}

      // Example of controlling a servo using accel data
      // aServo.write((Accel[0]/11) + 90);

      // Example of controlling a 2 servo sistem using touch pad data
      // aServo.write((TouchPadData[0][0] * 9) / 13); // x axis
      // anotherServo.write((TouchPadData[0][1] * 9) / 13); // y axis
      break;

    case CMD_ALIVE:
      // Character '[' is received every 2.5s, use
      // this event to refresh the android all button states
      for (int i = 0; i < MAX_TBUTTON; i++) {
        if (digitalRead(TButton_Output[i])) {
          Serial.println("<Butn" + TButton_ID[i] + ":1");
          Serial.println("<Imgs" + TButton_ID[i] + ":1");
        }
        else {
          Serial.println("<Butn" + TButton_ID[i] + ":0");
          Serial.println("<Imgs" + TButton_ID[i] + ":0");
        }
      }
      break;

    default:// If not '<' or '[' then appData may be for turning on or off relays
      // Handling toggle button data
      for (int i = 0; i < MAX_TBUTTON; i++) {
        if (appData == TButton_CMD_ON[i]) {
          Serial.println("<Vibr00:100");// vibrate 100ms
          Serial.println("<Alrm00");    // alarm beep
          digitalWrite(TButton_Output[i], HIGH);          // Write ouput port
          Serial.println("<Imgs" + TButton_ID[i] + ":1"); // Set image to pressed state
          break;
        }
        else if (appData == TButton_CMD_OFF[i]){
          digitalWrite(TButton_Output[i], LOW);           // Write ouput port
          Serial.println("<Imgs" + TButton_ID[i] + ":0"); // Set image to default state
          break;
        }
      }

      // Handling Image button data
      for (int i = 0; i < MAX_IBUTTON; i++) {
        if (appData == IButton_CMD_ON[i]) {
          Serial.println("<Alrm00");             // alarm beep
          digitalWrite(IButton_Output[i], HIGH); // Write ouput port
          break;
        }
        else if (appData == IButton_CMD_OFF[i]){
          digitalWrite(IButton_Output[i], LOW);  // Write ouput port
          break;
        }
      }
  }

  // ==========================================================================
  // Sending data to change images
  // This condition is true each 1/10 of a second approx
  if (digitalPrescaler++ > 100) {
    digitalPrescaler = 0;
    for (int i = 0; i < MAX_IMG; i++) {
      if (!digitalRead(IMG_Input[i]))
        Serial.println("<Imgs" + IMG_ID[i] + ":1"); // Set image to pressed state
      else
        Serial.println("<Imgs" + IMG_ID[i] + ":0"); // Set image to default state
    }
  }
  // End of loop
}

// DecodeSpecialCommand
//
// A '<' flags a special command comming from App. Use this function
// to get Accelerometer data (and other sensors in the future)
void DecodeSpecialCommand() {
  // Read the whole command
  String thisCommand = Serial.readStringUntil('\n');

  // First 5 characters will tell us the command type
  String commandType = thisCommand.substring(0, 5);

  if (commandType.equals("AccX:")) {
    // Next 6 characters will tell us the command data
    String commandData = thisCommand.substring(5, 11);
    if (commandData.charAt(0) == '-') // Negative acceleration
      Accel[0] = -commandData.substring(1, 6).toInt();
    else
      Accel[0] = commandData.substring(1, 6).toInt();
  }

  if (commandType.equals("AccY:")) {
    // Next 6 characters will tell us the command data
    String commandData = thisCommand.substring(5, 11);
    if (commandData.charAt(0) == '-') // Negative acceleration
      Accel[1] = -commandData.substring(1, 6).toInt();
    else
      Accel[1] = commandData.substring(1, 6).toInt();
  }

  if (commandType.equals("AccZ:")) {
    // Next 6 characters will tell us the command data
    String commandData = thisCommand.substring(5, 11);
    if (commandData.charAt(0) == '-') // Negative acceleration
      Accel[2] = -commandData.substring(1, 6).toInt();
    else
      Accel[2] = commandData.substring(1, 6).toInt();
  }

  if (commandType.substring(0, 4).equals("PadX")) {
    // Next 2 characters will tell us the touch pad number
    int padNumber = thisCommand.substring(4, 6).toInt();
    // Next 3 characters are the X axis data in the message
    String commandData = thisCommand.substring(8, 13);
    TouchPadData[padNumber][0] = commandData.toInt();
  }

  if (commandType.substring(0, 4).equals("PadY")) {
    // Next 2 characters will tell us the touch pad number
    int padNumber = thisCommand.substring(4, 6).toInt();
    // Next 3 characters are the Y axis data in the message
    String commandData = thisCommand.substring(8, 13);
    TouchPadData[padNumber][1] = commandData.toInt();
  }

  if (commandType.substring(0, 3).equals("Skb")) {
    // Next 6 characters will tell us the command data
    String commandData = thisCommand.substring(5, 11);
    int sbNumber = commandType.charAt(3) & ~0x30;
    SeekBarValue[sbNumber] = commandData.substring(1, 6).toInt();
  }

  if (commandType.equals("StoT:")) {
    // Next characters are the converted speech
    SpeechRecorder = thisCommand.substring(5, thisCommand.length() - 1); // there is a trailing character not known
  }
}
